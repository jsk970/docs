# 数据库事务的四大特性及事务的隔离级别

## 一、事务的四大特性 （ACID）

- 1、原子性（Atomicity）
>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
- 2、一致性（Consistency）
>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

- 3、隔离性（Isolation）
>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

- 4、持久性（Durability）
>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

## 二、事务的隔离级别（默认事务级别：可重复读）

### 并发事务带来的问题

- 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 ，最后的更新覆盖了由其他事务所做的更新。
  >例如，两个编辑人员制作了同一 文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。 最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同 一文件，则可避免此问题。
  > 
- 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做"脏读"。

- 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读” 。

- 幻读 （Phantom Reads）： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 。
### 幻读和不可重复读的区别

- 不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）

- 幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）

## 并发事务处理带来的问题的解决办法：
- “更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。
- “脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：
    - 一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。
    - 另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。


### SQL标准定义了4类隔离级别
> 每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

#### 第1级别：Read Uncommitted(读取未提交内容)

>所有事务都可以看到其他未提交事务的执行结果;
本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少;
该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据、不可重复读、幻读。

#### 第2级别：Read Committed(读取提交内容)

>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）;
它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变
这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。导致这种情况的原因可能有： 有一个交叉的事务有新的commit，导致了数据的改变;
一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit

#### 第3级别：Repeatable Read(可重读)

>这是MySQL的默认事务隔离级别
它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行
此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行
InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决幻读问题；InnoDB还通过间隙锁解决幻读问题

##### 多版本并发控制(解决幻读的问题) :
> Multi-Version Concurrency Control，即多版本并发控制

>Mysql的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。不过实现各不相同。
MVCC的实现是通过保存数据在某一个时间点快照来实现的。也就是说不管事务时间多长，每个事务看到的数据都是一致的。

分为`乐观（optimistic）并发控制`和`悲观（pressimistic）并发控制`。

- MVCC是如何工作的：
>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。
每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。

`REPEATABLE READ（可重复读）`隔离级别下MVCC如何工作：

SELECT
InnoDB会根据以下条件检查每一行记录：
InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的
行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除
只有符合上述两个条件的才会被查询出来

INSERT
InnoDB为新插入的每一行保存当前系统版本号作为行版本号

DELETE
InnoDB为删除的每一行保存当前系统版本号作为行删除标识

UPDATE
InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识

保存这两个版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且能保证只会读取到复合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。

MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。

可以认为MVCC是行级锁一个变种，但是他很多情况下避免了加锁操作，开销更低。虽然不同数据库的实现机制有所不同，但大都实现了非阻塞的读操作（读不用加锁，且能避免出现不可重复读和幻读），写操作也只锁定必要的行（写必须加锁，否则不同事务并发写会导致数据不一致）。

#### 第4级别：Serializable(可串行化)

>这是最高的隔离级别 ,它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。MySQL锁总结
在这个级别，可能导致大量的超时现象和锁竞争


***`隔离级别总结`***

|         隔离级别             |                          描述                           |
|-----------------------------|--------------------------------------------------------|
|READ UNCOMMITTED（读未提交数据）|允许事务读取未被其他事务提交的变更。脏读、不可重复读、幻读都会出现  |
|READ COMMITTED（读已提交数据）  |只允许事务读取已经被其他事务提交的变更，可以避免脏读。但是不可重复读和幻读仍可能出现 |
|REPEATABLE READ（可重复读）|确保一个事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务多这个字段进行更新。可以避免脏读和不可重复读，但是幻读仍会存在|
|SERIALIZABLE（串行化）|确保一个事务可以从一个表中多次读取相同的行，在这个事务持续期间，禁止其他事物对该表进行插入、更新、删除操作。所有并发问题都可以避免，但是性能十分低下|




